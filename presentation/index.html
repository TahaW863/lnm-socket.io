<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Building a realtime chrome extension with socket.io and node.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/custom.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<span class="twitter"><a>@mattsgarage</a></span>
		<div class="slides">
			<!-- Intro -->
			<section>
				<h3>Building a realtime chrome extension with socket.io and node.js</h3>
				<p>Matthew Lawson - Senior Developer</p>
				<p><a href="http://comparethemarket.com/">Comparethemarket.com</a></p>
			</section>
			<!-- What I will talk about -->
			<section>
				<h4>What I will talk about</h4>
				<ul>
					<li>Demo</l1>
						<li>Chrome Extension Terminology</li>
						<li>Socket.io Terminology</li>
						<li>High level design of the extension</li>
						<li>Dive into the code</li>
						<li>Malicious extensions / security</li>
				</ul>
			</section>
			<!-- Demo what was built -->
			<section>demo</section>
			<!-- Chrome Extension basic terminology -->
			<section>
				<section>chrome extension basic terminology</section>
				<section>
					<h4>The manifest.json</h4>
					<pre class="stretch">
						<code data-trim data-noescape>
							{
								"manifest_version": 2,
								"name": "Browser Chat",
								"description": "This extension is a mini socket.io chat client",
								"version": "0.1.0",
								"browser_action": {
									"default_icon": "images/browserActionIcon.png",
									"default_popup": "dist/index.html",
									"default_title": "Get your Quotes!"
								},
								"icons": {
									"16": "images/icon16.png",
									"48": "images/icon48.png",
									"128": "images/icon128.png"
								},
								"background": {
									"scripts": [
										"background.bundle.js"
									],
									"persistent": true
								},
								"permissions": [
									"activeTab",
									"notifications"
								]
							}
						</code>
					</pre>
				</section>
				<section>
					<h4>Browser Action</h4>
					<pre>
					<code data-trim data-noescape>
					{
						"browser_action": {
							"default_icon": "images/browserActionIcon.png",
							"default_popup": "dist/index.html",
							"default_title": "Get your Quotes!"
						}
					}
						</code>
					</pre>
					<p>Effectively a front end for the extension</p>
					<a href="https://developer.chrome.com/extensions/browserAction">More info</a>
				</section>
				<section>
					Page Actions
					<p>For extensions that only apply to certain pages</p>
					<p>Become greyed out if not appropriate for this page
						<p>
							<a href="https://developer.chrome.com/extensions/pageAction">More info</a>
				</section>
				<section>
					<h4>Background Pages</h4>
					<pre>
						<code data-trim data-noescape>
								"background": {
									"scripts": [
										"background.bundle.js"
									],
									"persistent": true
								},
							</code>
						</pre>
					<p>A long running script that is active once chrome is open</p>
					<p>Very powerful</p>
				</section>
				<section>
					<h4>event pages</h4>
					<pre>
							<code data-trim data-noescape>
									"background": {
										"scripts": [
											"background.bundle.js"
										],
										<mark>"persistent": false</mark>
									},
								</code>
							</pre>
					<p>A more efficient background page</p>
					<p>Sleeps when not required and reacts to events</p>
				</section>
				<section>
					<h4>Content Scripts</h4>
					<pre>
						<code data-trim data-noescape>
							"content_scripts": [
							{
								"matches": ["http://www.google.com/*"],
								"css": ["mystyles.css"],
								"js": ["jquery.js", "myscript.js"]
							}
						],
						</code>
					</pre>
					<p>Used when you need to interact with the current pages DOM, EG. An adblocker
						<p>
							<p>The script runs in isolation from the current pages javascript</p>
				</section>
				<section>
					<h4>Omnibox</h4>
					<img src="img/omnibox.png" />
					<pre>
							<code data-trim data-noescape>
								"omnibox": { "keyword" : "matt" },
								"icons": {
									"16": "16-full-color.png"
								},
								"background": {
									"persistent": false,
									"scripts": ["background.js"]
								}
							</code>
						</pre>
					<p>Background Script is sent events when the search keyword is activated <a href="https://developers.chrome.com/extensions/omnibox">More Info</a></p>
				</section>
			</section>
			<!-- Socket.io terminology -->
			<section>
				<section>
					socket.io terminology
				</section>
				<section>
					<h4>What is socket.io?</h4>
					<blockquote>
						"Socket.IO enables real-time bidirectional event-based communication.
						It works on every platform, browser or device, focusing equally on reliability and speed."
						<footer>
							<cite>- https://socket.io</cite>
						</footer>
					</blockquote>
				</section>
				<section>
					<pre>
						<code data-trim data-noescape>
								io.on('connection', (client) => {

								});
						</code>
					</pre>
					<p>Top level events, EG connection</p>
				</section>
				<section>
					<pre>
						<code data-trim data-noescape>
							io.emit(EVENT_NAME, {});
						</code>
					</pre>
					<span>Send message to all connected clients</span>
				</section>
				<section>
					<pre>
						<code data-trim data-noescape>
							io.on('connection', (client) => {
								client.broadcast.emit(EVENT_NAME, {});
							});
						</code>
					</pre>
					<span>Send a message to all connected clients apart from this client.</span>
				</section>
				<section>
					<h4>Rooms / namespace?</h4>
				</section>
			</section>
			<!-- Architecting the extension -->
			<section>
				<h4>Basic Architecture</h4>
				<img class="stretch" src="img/architecture.png" />
			</section>
			<!-- Network Diagram -->
			<section>
				<h4>Network Diagram</h4>
				<img class="stretch" src="img/network.png" />
			</section>
			<!-- Code breakdown -->
			<section>
				<section>node.js code</section>
				<section>
					<h4>Connecting</h4>
					<pre>
						<code data-trim data-noescape>
						// io.js
						const { global } = require('./constants');
						const debug = require('debug')(`${global.APP_NAME}:io`);
						const server = require('http').createServer();
						
						const io = require('socket.io')(server, {
							// Prioritise websocket first.
							transports: ['websocket', 'polling']
						});
						
						debug('Start socket.io listening');
						io.listen(3000);
						module.exports = io;
					</code>
					</pre>
					<p>Leverage node modules to access io object anywhere.</p>
				</section>
				<section>
					<h4>Handle connections and disconnections</h4>
					<pre>
						<code data-trim data-noescape>
						// monitorJoinLeaves.js
						const { messageTypes, global } = require('./constants');
						const io = require('./io');
						const debug = require('debug')(`${global.APP_NAME}:monitorJoinLeaves`);
						
						module.exports = () => {
							io.on('connection', (client) => {
								broadcastJoinNotification(client);
								broadcastConnectionCount();
								client.on('disconnect', () => {
									broadcastConnectionCount();
									broadcastDisconnect();
								});
							});
						}
						</pre>
					</code>
				</section>
				<section>
					<h4>Monitoring the message sending</h4>
						<pre>
							<code data-trim data-noescape>
								// monitorMessageSending.js
								const { messageTypes, global } = require('./constants');
								const io = require('./io');
								const debug = require('debug')(`${global.APP_NAME}:monitorMessageSending`);
								
								module.exports = () => {
									io.on('connection', (client) => {
										//Receive from client broadcast to everyone - but this client.
										client.on(messageTypes.SEND_MESSAGE, (message) => {
											debug(`Message received & broadcast: ${message}`);
											<mark>client.broadcast.emit(messageTypes.MESSAGE_TEXT, message);</mark>
										});
									});
								};
						</code>	
					</pre>
				</section>
				<section>
					<h4>Bringing it all together</h4>
					<pre>
						<code data-trim data-noescape>
								// index.js
								const { global } = require('./constants');
								const debug = require('debug')(`${global.APP_NAME}:index`);
								const monitorJoinLeaves = require('./monitorJoinLeaves')();
								const monitorMessageSending = require('./monitorMessageSending')();								
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					chrome extension
					<p><small>Background script</small></p>
				</section>
				<section>
					<h4>Connecting to the server</h4>
					<pre>
						<code data-trim data-noescape>
							// background.js
							import io from 'socket.io-client';
							const socket = io('http://localhost:3000');
							
							socket.on('connect', async () => {
								connectionStatus = messagePayloads.CONNECTED;
								const packet = {
									type: messageTypes.CONNECTION_CHANGE,
									payload: connectionStatus,
								}
								try {
									<mark>await sendChromeMessage(packet);</mark>
								}
								catch (err) { }
							});
						</code>
					</pre>
					<p>API is very similar to server side.</p>
				</section>
				<section>
					<h4>Sending messages to the browserAction</h4>
					<pre>
						<code data-trim data-noescape>
							export default (payload) => {
								return new Promise((resolve, reject) => {
									chrome.runtime.sendMessage(payload, function (response) { //eslint-disable-line no-undef
										if (response) {
											resolve(response);
										}
										else {
											reject("browserAction not open");
										}
									});
								});
							}
						</code>
					</pre>
					<p>Communication between different scripts in the extension uses chrome.runtime.* methods</p>
				</section>
				<section>
					<h4>Receiving messages from the browserAction</h4>
					<pre>
						<code data-trim data-noescape>
							chrome.runtime.onMessage.addListener( //eslint-disable-line no-undef
								(request, sender, sendResponse) => {
									switch (request.type) {
										...
										case messageTypes.SEND_MESSAGE:
											// Send to socket client
											sendMessageFromClient(request.message);
											break;
										...
									}
								}
							);
						</code>
					</pre>
				</section>
			</section>
			<section>
				<section>
					chrome extension
					<p><small>Browser Action</small></p>
				</section>
				<section>
					<h4>Getting the initial messages from the background</h4>
					<pre>
						<code data-trim data-noescape>
							// actions.js
							// Redux thunk action creator
							export const fetchMessages = (params) => async dispatch => {
								try {
									const messages = await sendChromeMessage(fetchMessageAction());
									dispatch(messageFetchedSuccess(messages));
								}
								catch(err) { }
							}
							...
							// ChatWindow/index.js
							componentDidMount() {
								// Fetch messages when chrome window opens
								this.props.fetchMessages();
							}
							...
						</code>
					</pre>
					<p><small>browserAction has no long life process, it is destroyed everytime it closes</small></p>
				</section>
				<section>
						<h4>Communication is the same as background -> browserAction</h4>
						<pre>
							<code data-trim data-noescape>
									// sendChromeMessage.js
									export default (payload) => {
										console.log("Sending chromeMessage: ", payload);
										return new Promise((resolve, reject) => {
											chrome.runtime.sendMessage(payload, function (response) { //eslint-disable-line no-undef
												if (response) {
													resolve(response);
												}
												else {
													reject("browserAction not open");
												}
											});
										});
									}
							</code>
						</pre>
						<p><small>Wrap sendMessage() callback in a Promise so we can use async / await</small></p>
					</section>
			</section>
			<!-- What else could be done? -->
			<section>
				<section>What else could be done?</section>
				<section>
					<h4>Notifications</h4>
					<p><img src="img/notification.png" /></p>
					<h4>Badges</h4>
					<p><img src="img/badges.png" /></p>
				</section>
				<section>
					<h4>Extra permissions are required to send Notifications</h4>
						<pre>
							<code data-trim data-noescape>
								"permissions": [
									"activeTab",
									"alarms",
									"notifications"
								]	
							</code>
						</pre>
						<img src="img/permissions.png" />
				</section>
				<section>
					Store state in chrome storage
				</section>
			</section>
			<section>
				<h4>Security Concerns?</h4>
				<ul>
					<li class="fragment">Content Scripts allow to read the DOM</li>
					<li class="fragment">Browser actions can read the current active tab without notifying on install</li>
					<li class="fragment">Store submission review</li>
					<li class="fragment">Read the install permissions closely</li>
					<li class="fragment">What is googles plan for extensions?</li>
				</ul>
				<blockquote class="fragment">If you are installing from the extension store you will probably be ok.</blockquote>
			</section>
			<section>
				<h4>Future of Chrome extensions</h4>
				<p>No new API's since chrome 46 / late 2015</p>
			</section>
			<section>questions</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>